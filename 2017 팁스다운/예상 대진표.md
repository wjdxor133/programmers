# 문제 설명

<img width="531" alt="예상 대진표 문제" src="https://user-images.githubusercontent.com/47416686/125227261-86c3f000-e30d-11eb-83f3-39448ecfd499.png">

## 입출력 예

<img width="531" alt="예상 대진표 입출력" src="https://user-images.githubusercontent.com/47416686/125227257-8592c300-e30d-11eb-9499-6a477b370177.png">

### 입출력 예 설명

**입출력 예 #1**

첫 번째 라운드에서 4번 참가자는 3번 참가자와 붙게 되고, 7번 참가자는 8번 참가자와 붙게 됩니다.

항상 이긴다고 가정했으므로 4번 참가자는 다음 라운드에서 2번이 되고, 7번 참가자는 4번이 됩니다.

두 번째 라운드에서 2번은 1번과 붙게 되고, 4번은 3번과 붙게 됩니다.

항상 이긴다고 가정했으므로 2번은 다음 라운드에서 1번이 되고, 4번은 2번이 됩니다.

세 번째 라운드에서 1번과 2번으로 두 참가자가 붙게 되므로 3을 return 하면 됩니다.

## 문제 설명

도저히 어떻게 접근해야 할지 모르겠어서 구글링을 통해서 `토너먼트 알고리즘에 대한 규칙`을 찾아보았다.

### 🔎 **접근 방식**

부전승이 따로 있지 않고, 참가자가 2의 제곱으로 주어지기 때문에 한 번 라운드가 끝날 때 마다 참가자가 `이전라운드 참가자의 2분의 1로 줄어드는 것을 확인`할 수 있었다.

단, 짝수인 경우의 참가자는 2분의 1로 줄어들면 딱 떨어지지만, 홀수인 경우의 참가자를 2분의 1로 줄어들면 정확하게 나누어 떨어지지 않는다.

먼저 간단하게 규칙을 찾아보았다.

1 → `1 / 2 = 0`, `1 % 2 = 1` ⇒ 1

2 → `2 / 2 = 1`, `2 % 2 = 0` ⇒ 1

3 → `3 / 2 = 1`, `3 % 2 = 1` ⇒ 2

4 → `4 / 2 = 2`, `4 % 2 = 0` ⇒ 2

5 → `5 / 2 = 3`, `5 % 2 = 1` ⇒ 3

6 → `6 / 2 = 3`, `6 % 2 = 0` ⇒ 3

7 → `7 / 2 = 3`, `7 % 2 = 1` ⇒ 4

8 → `8 / 2 = 4`, `8 % 2 = 0` ⇒ 4

홀수 인경우, 나머지가 1이 되기 때문에 나머지를 더해서 짝수로 맞춘다.

그럼 이제 자기 번호에서 승리를 한다고 할때 `그 대진표의 짝수번호 / 2`의 위치로 올라가게 된다.

4번은 짝수 참가자이기 때문에 이기번 2번으로 올라가게 되고,

7번은 홀수 참가자이기 때문에, 4번으로 올라가게 된다.

이걸 이용해서 두수를 계속 2로 나눈다면 같은수가 될때 만나게 된다.

예를 들어 4번과 7번이 몇번째에 만나게 되는지 계산한다고 할때

1. **a = 4**, **b = 7**

   `a` → 4 / 2 = 2

   `b` → (7+1) / 2 = 4 -> 짝수여야 하므로 보정해준다.

2. **a = 2**, **b = 4**

   `a` → 2 / 2 = 1

   `b` → 4 / 2 = 2

3. **a = 1,** **b = 2**

   `a` → (1+1) / 2 = 1

   `b` → 2 / 2 = 1

이렇게 두 수가 같아지는 순간이 3번째 계산이므로 답은 3이된다.

## 내가 짠 코드

```jsx
function solution(n, a, b) {
  let round = 0;

  while (a !== b) {
    a = Math.floor(a / 2) + (a % 2);
    b = Math.floor(b / 2) + (b % 2);
    round++;
  }

  return round;
}
```

## ✔️ 참고

[코딩테스트 연습 - 예상 대진표](https://programmers.co.kr/learn/courses/30/lessons/12985)
